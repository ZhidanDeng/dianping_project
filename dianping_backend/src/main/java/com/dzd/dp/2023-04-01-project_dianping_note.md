###什么是缓存  
缓存是数据交换的缓冲区，也称作cache，是存储数据的临时地方，一般读写性能较高。  
####作用  
1. 降低后端负载  
2. 提高读写效率，降低响应时间  
####成本  
1. 数据一致性成本：数据库发生了变化，缓存中的数据可能是旧的。  
2. 代码维护成本(缓存穿透
3. 运维成本(集群)  

###添加Redis缓存  
###缓存更新策略  
1. 内存淘汰：内存不足时，自动淘汰部分数据。一致性差，无维护成本。
2. 超时剔除：数据到期后自动删除，一致性一般，维护成本低。
3. 主动更新：编写业务逻辑，修改数据库的同时，更新缓存。一致性好，维护成本高。  

主要看业务场景：低一致性需求用内存淘汰，高一致性需求用主动更新+超时剔除兜底。  
###主动更新策略  
有3种，重点是旁路缓存模式(cache aside pattern)，它由缓存的调用者在更新数据库的同时，更新缓存。  
  
写操作：先写数据库，再删缓存，同时要确保数据库和缓存操作的原子性。

###缓存穿透  
指客户端请求的数据都不在缓存和数据库中，这样缓存永远不会生效，这些请求都会打到数据库。  
常见的解决方案有两种：
1. 缓存空对象：实现简单，维护方便。缺点是额外的内存消耗(可以通过设置超时ttl缓解)、可能造成短期的不一致  
2. 布隆过滤：在缓存之前添加一个布隆过滤器，数据不存在则直接拒绝，存在再查询redis\数据库


###缓存雪崩  
同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。  

###解决方案  
1. 给不同的key的TTL添加随机值
2. 利用Redis集群提高服务的高可用性
3. 给缓存业务添加降级限流策略
4. 给业务添加多级缓存  

###缓存击穿  
也叫热点Key问题，就是一个高并发访问并且缓存重建业务比较复杂的key突然失效了，无数的请求访问瞬间给数据库带来巨大的冲击。  
###解决方案
1. 互斥锁
2. 逻辑过期(还是需要锁，但是是让子线程去重建缓存)  

###redis 消息队列
####基于List结构模拟消息队列
利用redis的list结构，模拟jvm的阻塞队列(lpush+brpop || rpush+blpop).  
优点：1)不受限与jvm的内存上限。2)基于redis的持久化，保证数据安全性。3)可以满足消息有序性.  
缺点：1)无法避免消息丢失。2)只支持单消费者  
####基于PubSub的消息队列
基于发布订阅模式，消费者可以订阅一个或多个channel，生产者向对应channel发送消息之后，所有的订阅者都能收到相关消息。  
优点：1)支持多生产、多消费   
缺点：1)不支持数据持久化.2)无法避免消息丢失。3)消息堆积有上限，超出时数据丢失。
####基于Stream的消息队列
Stream是redis5.0引入的一种新的消息类型。  
可能会漏读消息！！！！
####基于Stream的消息队列---消费者组
消费者组：将多个消费者分到一个组中，监听同一个队列，具有以下特点：  
1)消息分流  

2)消息标识：消费者组维护一个标识，记录最后一个被处理的消息  

3)消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完后需要通过XACK确认消息，标记消息已被处理，才会从pending-list移除。  
XGROUP CREATE key groupName ID 
